Арканоид(8)
Но и это еще не все.
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw(Canvas canvas) и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность (пока можешь оставить их пустыми, просто чтобы код компилировался).
Объяви эти методы, но сделай их абстрактными.
Также сделай абстрактным сам класс BaseObject.

А еще нам нужно будет определять попал ли шарик в кирпич или в подставку.
Это будем делать так:
В этом же классе, создадим специальный метод: boolean intersects(BaseObject o)
Он будет определять - "пересеклись" объекты или нет. Если пересеклись - возвращать true, если нет - false.

Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия:
если центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.

Или еще проще:
дистанция_между_объектами <= max (радиус_первого_объекта, радиус_второго_объекта)

Дистанция между объектами A и B на плоскости вычисляется по теореме Пифагора по формуле:
дистанция_между_объектами_A_B = квадратный_корень(
квадрат_числа(координата_x_объекта_B - координата_x_объекта_A) +
квадрат_числа(координата_y_объекта_B - координата_y_объекта_A)
)
Квадратный корень можно получить используя метод Math.sqrt(). Квадрат числа можно получить используя метод Math.pow(), где первый аргумент - это число, второй аргумент - степень, к которой нужно возвести число.
Или еще проще используя метод Math.hypot().


Requirements:
1. Класс BaseObject должен быть абстрактным.
2. В классе BaseObject должен быть объявлен абстрактный метод void draw() c одним параметром типа Canvas.
3. В классе BaseObject должен быть объявлен абстрактный метод void move() без параметров.
4. В классе BaseObject должен быть реализован метод intersects() с одним параметром типа BaseObject, возвращающий true в случае, если текущий объект пересекается с анализируемым.


Арканоид(9)
Теперь займемся классом Canvas.
Он у нас будет содержать матрицу (двумерный массив), куда мы будем "рисовать".
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).

Надо:
а) Добавить в класс два приватных поля width и height.
б) Добавить в класс приватное поле matrix (char[][]).
в) Добавить конструктор с двумя параметрами типа int (width и height), поле matrix должно быть инициализировано пустым массивом размерностью [height+2][width+2].
г) Добавить геттеры и сеттеры для всех приватных полей класса.


Requirements:
1. В классе Canvas должно быть создано приватное поле width типа int.
2. В классе Canvas должно быть создано приватное поле height типа int.
3. В классе Canvas должно быть создано приватное поле matrix типа char[][].
4. В классе Canvas должен быть создан публичный геттер для поля width.
5. В классе Canvas должен быть создан публичный геттер для поля height.
6. В классе Canvas должен быть создан публичный геттер для поля matrix.
7. В классе Canvas должен быть создан публичный сеттер для поля width.
8. В классе Canvas должен быть создан публичный сеттер для поля height.
9. В классе Canvas должен быть создан публичный сеттер для поля matrix.
10. В классе Canvas должен быть создан корректный публичный конструктор с двумя параметрами типа int (width и height).



Арканоид(10)
Что мы будем делать с Canvas?
Мы будем рисовать на нем (в его матрице).
Поэтому нам понадобятся два метода:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)

Первый метод - setPoint будет "ставить точку в координатах x,y цветом c".

В методе надо:
а) округлить x и y до целых чисел, используя метод Math.round()
б) занести в matrix[y][x] значение с
в) ничего не делать, если x < 0 или y < 0 или y >= matrix.length или x >= matrix[0].length

Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y

В методе надо:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки
б) если значение ячейки элемента [i][j] полученной матрицы не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
setPoint(x+j, y+i, c)


Requirements:
1. В классе Canvas должен быть создан метод void setPoint(double x, double y, char c).
2. В классе Canvas должен быть создан метод void drawMatrix(double x, double y, int[][] matrix, char c).
3. Поведение метода setPoint должно соответствовать условию задачи.
4. Поведение метода drawMatrix должно соответствовать условию задачи.

Арканоид(12)
Теперь займемся классом Brick.

Во-первых, в конструкторе точно зададим "радиус" всех кирпичей.
Пусть он выглядит так:
public Brick(double x, double y) {
  super(x, y, 3);
}

Еще убедись, что в классе Brick есть два переопределенных метода: move() и draw(Canvas canvas).
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Кодом метода draw(Canvas canvas) я займусь сам.


Requirements:
1. Конструктор класса Brick должен принимать два параметра типа double и вызывать конструктор класса родителя с фиксированным третьим параметром (радиусом) равным 3.
2. В классе Brick должен существовать метод move без параметров.
3. В классе Brick должен существовать метод draw с одним параметром типа Сanvas.

Арканоид(13)
Класс Ball уже посложнее - шарик же двигается.

Нам понадобятся приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения в градусах: от 0 до 360) типа double;
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
д) isFrozen ("истина" если шарик "заморожен" - не двигается) типа boolean.

Не забудь добавить геттеры для всех полей этого класса, кроме isFrozen (его мы будем использовать только внутри класса Ball).

А еще сделай-ка конструктор:
а) параметры - x, y, speed, direction;
б) радиус (для вызова родительского класса) всегда равен 1;
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.


Requirements:
1. Приватное поле speed типа double должно быть создано в классе Ball.
2. Приватное поле direction типа double должно быть создано в классе Ball.
3. Приватное поле dx типа double должно быть создано в классе Ball.
4. Приватное поле dy типа double должно быть создано в классе Ball.
5. Приватное поле isFrozen типа boolean должно быть создано в классе Ball.
6. В классе Ball должен быть создан публичный конструктор (поведение и параметры описаны в условии).
7. В классе Ball должен существовать корректный публичный геттер для поля speed.
8. В классе Ball должен существовать корректный публичный геттер для поля direction.
9. В классе Ball должен существовать корректный публичный геттер для поля dx.
10. В классе Ball должен существовать корректный публичный геттер для поля dy.

Арканоид(14)
Чего-то не хватает в классе Ball:

Во-первых надо реализовать метод move(), унаследованный от BaseObject:
а) x должен увеличиваться на dx каждый ход
б) y должен увеличиваться на dy каждый ход
если шарик "заморожен", то x и y меняться не должны

Во-вторых надо реализовать метод draw(Canvas canvas):
на объекте canvas необходимо вызвать метод setPoint с параметрами (x, y, 'O')

В-третьих надо создать и реализовать метод void start():
именно его вызов "размораживает" шарик.
Что для этого надо сделать - это ты уже сам реши.

P.S. Чуть не забыл! Поля x, y и radius объявлены в классе BaseObject с модификатором доступа private, что не очень-то удобно.
Измени его на protected, чтобы все потомки класса BaseObject имели контроль над своими координатами и размерами, без необходимости пользоваться " чужими" геттерами и сеттерами.


Requirements:
1. Метод move() в классе Ball должен увеличивать значение x на dx, если значение поля isFrozen равно false.
2. Метод move() в классе Ball должен увеличивать значение y на dy, если значение поля isFrozen равно false.
3. Метод move() в классе Ball не должен менять значения полей x и y, если значение поля isFrozen равно true.
4. В классе Ball должен быть реализован метод draw(Canvas canvas) в соответствии с условием задачи.
5. В классе Ball должен быть реализован метод start() устанавливающий значение поля isFrozen в false.
6. Модификатор доступа поля x в классе BaseObject должен быть изменен на protected.
7. Модификатор доступа поля y в классе BaseObject должен быть изменен на protected.
8. Модификатор доступа поля radius в классе BaseObject должен быть изменен на protected.



Арканоид(15)
Не поверишь, но и это еще не все. Продолжим реализацию класса Ball.

Во-первых нужен метод setDirection, который не только устанавливает значение переменной direction, но и вычисляет новые значения переменных dx и dy.

Код должен выглядеть примерно так:
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.

Во-вторых шарик может удариться о стенку.
При этом он должен от нее отскочить.

Для этого нам понадобится еще один метод:
void checkRebound(int minx, int maxx, int miny, int maxy)

Создай его, а кодом я займусь сам.


Requirements:
1. В классе Ball должен быть создан метод void setDirection() c одним параметром типа double (реализацию смотри в условии).
2. В классе Ball должен быть создан метод void checkRebound c четырьмя параметрами типа int.

Арканоид(16)
И наконец "подставка"!
Ей понадобятся такие приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения по оси x: 1 - вправо, -1 - влево, 0 - начальное значение, стоим на месте) типа double.

Также создай для них геттеры.

А еще с тебя конструктор, примерно вот такой:
public Stand(double x, double y) {
super(x, y, 3);
speed = 1;
direction = 0;
}


Requirements:
1. В классе Stand должно быть создано приватное поле speed типа double.
2. В классе Stand должно быть создано приватное поле direction типа double.
3. В классе Stand должен быть реализован публичный геттер для поля speed.
4. В классе Stand должен быть реализован публичный геттер для поля direction.
5. В классе Stand должен быть реализован конструктор с двумя параметрами типа double в соответствии с условием задачи.


Арканоид(17)
Еще подставке нужны методы:
а) move - см. move в BaseObject
Движение доски осуществляется горизонтально, поэтому мы меняем только координату х.
Подумай, как координата х зависит от направления (direction) и скорости (speed). Реализуй зависимость.
б) draw - см. draw в BaseObject
Его кодом я займусь сам.
в) moveLeft() - задает постоянное движение "подставки" влево
Просто присвой правильное значение переменной direction.
г) moveRight() - задает постоянное движение "подставки" вправо
Просто присвой правильное значение переменной direction.


Requirements:
1. В классе Stand должен быть реализован метод move увеличивающий координату x на произведение значений полей speed и direction.
2. В классе Stand должен быть реализован метод moveLeft, устанавливающий значение поля direction равным -1.
3. В классе Stand должен быть реализован метод moveRight, устанавливающий значение поля direction равным 1.


Арканоид(18)
Теперь вернемся к классу Arkanoid.

Реализуй метод move():
В этом методе нужно двигать все движимые объекты (stand, ball).
Создай и реализуй метод void draw(Canvas canvas).
В этом методе надо вызвать метод draw всех существующих объектов, которые его имеют.


Requirements:
1. В классе Arkanoid должен быть реализован метод move() без параметров, вызывающий методы move() у шарика и подставки.
2. В классе Arkanoid должен быть реализован метод draw(Canvas canvas), вызывающий методы draw у шарика, подставки и всех кирпичей.



Арканоид(19)
Осталось совсем чуть-чуть.

В классе Arkanoid создай поле приватное isGameOver типа boolean.

Создай и реализуй метод void checkBricksBump().
В этом методе надо проверить - не столкнулся ли шарик с каким-нибудь из "кирпичей".
Для проверки столкновения используй метод intersects().
Если шарик все-таки попал в кирпич, то:
а) шарик отлетает в случайном направлении:
double angle = Math.random() * 360;
ball.setDirection(angle);
б) кирпич умирает - надо удалить его из списка всех кирпичей.

Создай и реализуй метод void checkStandBump().
В этом методе надо проверить - не ударился ли шарик о подставку.
Для проверки столкновения используй метод intersects().
Если шарик все-таки ударился о подставку, то:
шарик отлетает в случайным направлении вверх:
double angle = 90 + 20 * (Math.random() - 0.5);
ball.setDirection(angle);

Создай и реализуй метод void checkEndGame().
Если координата y шарика больше чем высота поля игры (height), значит шарик улетел вниз за границу экрана.
В этом случае надо переменную isGameOver установить в true.


Requirements:
1. В классе Arkanoid должен быть реализован метод checkBricksBump() в соответствии с условием задачи.
2. В классе Arkanoid должен быть реализован метод checkStandBump() в соответствии с условием задачи.
3. В классе Arkanoid должно быть создано приватное поле isGameOver типа boolean.
4. В классе Arkanoid должен быть реализован метод checkEndGame() в соответствии с условием задачи.























